swift recap
#===== constant chapter ========
https://chatgpt.com/share/687877a6-3a58-8003-b9ad-6cb53b2f9f75

| Concept          | Keyword  | Mutable | Can be nil?         | Example                 |
| ---------------- | -------- | ------- | ------------------- | ----------------------- |
| Constant         | `let`    | âŒ       | âŒ (unless optional) | `let age = 30`          |
| Variable         | `var`    | âœ…       | âŒ (unless optional) | `var name = "Sam"`      |
| Optional         | `?`      | âœ…       | âœ…                   | `var name: String?`     |
| Forced Unwrap    | `!`      | -       | -                   | `name!`                 |
| Optional Binding | `if let` | -       | -                   | `if let name = name {}` |
| Nil-Coalescing   | `??`     | -       | -                   | `name ?? "Guest"`       |


==== control flow chapter ====
https://chatgpt.com/share/68919527-c330-8003-95ef-c46995d19e4c




| Statement     | Purpose                        |
| ------------- | ------------------------------ |
| `break`       | Exit current loop/switch early |
| `continue`    | Skip to next iteration         |
| `fallthrough` | Continue to next `switch` case |
| `return`      | Exit from function             |


==== DAY 3 functions ======
https://chatgpt.com/share/6895d3a4-d794-8003-a49f-718aeb919458

#======== day 4 enum chapter =======
link :
https://chatgpt.com/share/68918c66-530c-8003-a610-8d064c93fd44


| Feature             | Raw Values                      | Associated Values                          |
| ------------------- | ------------------------------- | ------------------------------------------ |
| Purpose             | Assign constant value           | Attach custom data to cases                |
| Value Type          | Must be same type for all cases | Can vary in type and number across cases   |
| Set at declaration? | âœ… Yes                           | âŒ No, provided when creating enum instance |
| Access              | `case.rawValue`                 | `switch` pattern matching                  |
| Example             | `.monday.rawValue` â†’ `"Mon"`    | `.failure(errorCode: 404)`                 |

| Feature               | Raw Values                                     |
| --------------------- | ---------------------------------------------- |
| Type requirement      | Must be same for all cases                     |
| Why?                  | To allow `.rawValue` access and initialization |
| Enforced by compiler? | âœ… Yes                                          |

=== properties ====
ğŸ“Œ Interview Summary (Cheat Sheet)
Type	Stores Value?	When Used?	Example Use Case
Stored	âœ… Yes	Keep simple data	var name: String
Computed	âŒ No	Derived value	area = width * height
Lazy Stored	âœ… (delayed)	Expensive init, depends on self	lazy var db = Database()
Property Observers	âœ… (monitors)	Track changes	didSet { ... }
ğŸ‘€ Property Observers in Swift

ğŸ‘‰ Definition:
Property observers are blocks of code that run whenever the value of a property changes.
They let you react to changes instead of recomputing values like computed properties.

âœ… Types of Property Observers

There are two observers:

willSet

Called before the value is changed.

The new value is passed as a constant (newValue by default, or you can give it a custom name).

didSet

Called after the value is changed.

The old value is passed as a constant (oldValue by default).

ğŸ“Œ Rules to Remember

You can use both willSet and didSet together or only one.

They can be applied to stored properties (var, not let).

They cannot be applied to lazy properties (since lazy is initialized only once).

They are not called during initialization (inside init or at declaration).

They can be added to inherited properties by overriding.

================== functions in swift ===== 

ğŸ”¹ Interview Traps & Deep Insights

Q: Why does a struct need mutating but a class does not?
ğŸ‘‰ Because structs are value types. Inside methods, self is a constant copy by default. To modify, you must mark the method mutating.
Classes are reference types, so methods can always mutate stored properties without restriction.

Q: Can static methods access instance properties?
âŒ No.
They belong to the type, so they donâ€™t have an instance context.
They can only access static properties/methods.

Q: Can instance methods call type methods and vice versa?

Instance â†’ Type âœ… Yes (via TypeName.method() or Self.method()).

Type â†’ Instance âŒ No (needs an instance first).

Q: Can mutating methods be called on let constants?

var p = Point(x: 0, y: 0) // âœ… works
p.moveBy(dx: 1, dy: 1)

let q = Point(x: 0, y: 0) // âŒ error
q.moveBy(dx: 1, dy: 1)


ğŸ‘‰ Because let makes the struct completely immutable.

Q: Can enums have mutating methods?
âœ… Yes, commonly used for state toggling.

ğŸ”¹ Quick Comparison Table
Feature	Instance Method	Type Method (static/class)	Mutating Method (Struct/Enum)
Belongs to	Instance	Type	Instance (value types only)
Access instance props	âœ… Yes	âŒ No	âœ… Yes (after mutating)
Access type props	âœ… Yes	âœ… Yes	âœ… Yes
Needed for mutation	Only for value types (struct/enum)	Not applicable	Required to modify/reassign self

âš¡ Interview-ready takeaway:

Use instance methods for behavior tied to objects.

Use type methods for utilities and shared state.

Use mutating methods in value types when modifying properties or self.
==
Final Interview-Ready Summary

Instance â†’ Type âœ… Works (because an instance always knows its type).

Type â†’ Instance âŒ Not possible directly (because type has no instance context).

âœ… If needed, type methods must create or receive an instance to call its instance methods.
