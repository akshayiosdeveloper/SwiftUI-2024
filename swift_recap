swift recap
#===== constant chapter ========
https://chatgpt.com/share/687877a6-3a58-8003-b9ad-6cb53b2f9f75

| Concept          | Keyword  | Mutable | Can be nil?         | Example                 |
| ---------------- | -------- | ------- | ------------------- | ----------------------- |
| Constant         | `let`    | ❌       | ❌ (unless optional) | `let age = 30`          |
| Variable         | `var`    | ✅       | ❌ (unless optional) | `var name = "Sam"`      |
| Optional         | `?`      | ✅       | ✅                   | `var name: String?`     |
| Forced Unwrap    | `!`      | -       | -                   | `name!`                 |
| Optional Binding | `if let` | -       | -                   | `if let name = name {}` |
| Nil-Coalescing   | `??`     | -       | -                   | `name ?? "Guest"`       |


==== control flow chapter ====
https://chatgpt.com/share/68919527-c330-8003-95ef-c46995d19e4c




| Statement     | Purpose                        |
| ------------- | ------------------------------ |
| `break`       | Exit current loop/switch early |
| `continue`    | Skip to next iteration         |
| `fallthrough` | Continue to next `switch` case |
| `return`      | Exit from function             |


==== DAY 3 functions ======
https://chatgpt.com/share/6895d3a4-d794-8003-a49f-718aeb919458

#======== day 4 enum chapter =======
link :
https://chatgpt.com/share/68918c66-530c-8003-a610-8d064c93fd44


| Feature             | Raw Values                      | Associated Values                          |
| ------------------- | ------------------------------- | ------------------------------------------ |
| Purpose             | Assign constant value           | Attach custom data to cases                |
| Value Type          | Must be same type for all cases | Can vary in type and number across cases   |
| Set at declaration? | ✅ Yes                           | ❌ No, provided when creating enum instance |
| Access              | `case.rawValue`                 | `switch` pattern matching                  |
| Example             | `.monday.rawValue` → `"Mon"`    | `.failure(errorCode: 404)`                 |

| Feature               | Raw Values                                     |
| --------------------- | ---------------------------------------------- |
| Type requirement      | Must be same for all cases                     |
| Why?                  | To allow `.rawValue` access and initialization |
| Enforced by compiler? | ✅ Yes                                          |

=== properties ====
📌 Interview Summary (Cheat Sheet)
Type	Stores Value?	When Used?	Example Use Case
Stored	✅ Yes	Keep simple data	var name: String
Computed	❌ No	Derived value	area = width * height
Lazy Stored	✅ (delayed)	Expensive init, depends on self	lazy var db = Database()
Property Observers	✅ (monitors)	Track changes	didSet { ... }
👀 Property Observers in Swift

👉 Definition:
Property observers are blocks of code that run whenever the value of a property changes.
They let you react to changes instead of recomputing values like computed properties.

✅ Types of Property Observers

There are two observers:

willSet

Called before the value is changed.

The new value is passed as a constant (newValue by default, or you can give it a custom name).

didSet

Called after the value is changed.

The old value is passed as a constant (oldValue by default).

📌 Rules to Remember

You can use both willSet and didSet together or only one.

They can be applied to stored properties (var, not let).

They cannot be applied to lazy properties (since lazy is initialized only once).

They are not called during initialization (inside init or at declaration).

They can be added to inherited properties by overriding.

================== functions in swift ===== 

🔹 Interview Traps & Deep Insights

Q: Why does a struct need mutating but a class does not?
👉 Because structs are value types. Inside methods, self is a constant copy by default. To modify, you must mark the method mutating.
Classes are reference types, so methods can always mutate stored properties without restriction.

Q: Can static methods access instance properties?
❌ No.
They belong to the type, so they don’t have an instance context.
They can only access static properties/methods.

Q: Can instance methods call type methods and vice versa?

Instance → Type ✅ Yes (via TypeName.method() or Self.method()).

Type → Instance ❌ No (needs an instance first).

Q: Can mutating methods be called on let constants?

var p = Point(x: 0, y: 0) // ✅ works
p.moveBy(dx: 1, dy: 1)

let q = Point(x: 0, y: 0) // ❌ error
q.moveBy(dx: 1, dy: 1)


👉 Because let makes the struct completely immutable.

Q: Can enums have mutating methods?
✅ Yes, commonly used for state toggling.

🔹 Quick Comparison Table
Feature	Instance Method	Type Method (static/class)	Mutating Method (Struct/Enum)
Belongs to	Instance	Type	Instance (value types only)
Access instance props	✅ Yes	❌ No	✅ Yes (after mutating)
Access type props	✅ Yes	✅ Yes	✅ Yes
Needed for mutation	Only for value types (struct/enum)	Not applicable	Required to modify/reassign self

⚡ Interview-ready takeaway:

Use instance methods for behavior tied to objects.

Use type methods for utilities and shared state.

Use mutating methods in value types when modifying properties or self.
==
Final Interview-Ready Summary

Instance → Type ✅ Works (because an instance always knows its type).

Type → Instance ❌ Not possible directly (because type has no instance context).

✅ If needed, type methods must create or receive an instance to call its instance methods.
